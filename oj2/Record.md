# OJ_2_Record

> 主要使用动态规划解决

## A. Optimal Display Rental

> 给定一个<size, val>数组，要求找出三个依次序size递增的元素，使得val的和最小

### 思路

由于题目提供的数组size不大，<2000，故空间复杂度在可接受范围内

对于数组中任一点，我们分别维护两个量

leftMin[n]和rightMin[n]

分别对应该点左边size小于它和右边size大于它的最小val

这样一下，要计算最小的val和只需要遍历一遍这两个数组，依次从leftMin和rightMin中取值与该点自身相加即可（即相当于把这个点当成中间的那个点）

### 优化？

维护这两个数组本身最笨的方法都是使用双循环实现的，即遍历该点左边所有size符合要求的点找到左侧最小值存下来，遍历该点右边所有size符合要求的点找到右侧最小值存下来，总体下来时间复杂度来到了$\Theta(n^2)$，但万幸可以通过oj成功ac，问题是这里可以进一步优化嘛？



## B. Sheep Transport Problem

> 牧羊人鲍勃正在他的农场上赶着 N 只羊（1 <= N <= 2500），但在路上遇到了一条河阻挡了他的去路。可用的只有一只木筏。
>
> 鲍勃知道，他必须在每次过河时都要乘坐木筏，且添加羊只会延长过河的时间。
>
> - 当鲍勃独自乘坐木筏时，过河需要 M 分钟（1 <= M <= 1000）。
> - 当第 i 只羊被添加到木筏上时，它过河的时间比带着第 i-1 只羊时多了 M~i~ 分钟（即：带一只羊的总时间是 M+M~1~，带两只羊的总时间是 M+M~1~+M~2~，以此类推）。
>
> 请计算鲍勃将所有羊送过河所需的最短时间（包括他返回接送更多羊的时间）。

### 问题说明

🐏本身不区分，只区分🐏的个数

如输入

```bash
5 10
3
4
6
100
1
```

代表五只🐏，人单独过河时间为10

每次增加一只🐏时用时增加幅度为 3 4 6 100 1

带一只羊过河需要 10+3分钟。

带两只羊过河需要 10+3+4分钟

···

带五只羊过河需要 10+3+4+6+100+1分钟。

故一个策略是，第一趟带三只🐏，第二趟带两只🐏，共用时23+10+17=50

### 状态分析和状态转移函数

设dp[n+1]表示带n只🐏的最短用时

维护一个数组记录直接带n只🐏过河需要的时间为cross_time[n+1]

先说明边界情况

dp[0]表示带0只🐏过河最短时间，显然为m

cross_time[0]表示直接带0只🐏过河的时间，显然也为m

且$cross\_time[i] = m+\sum_{k=1}^{i}m_k$

维护cross_time用时为$\Theta(n)$

下面给出状态转移函数
$$
\begin{equation}
dp[i] = min(dp[i], dp[i-j]+cross\_time[j]+m,cross_time[i])
\end{equation}
$$
式中$1\le j\le i-1$表示分为两部分，第一部分为运i-j只🐏时的最优解，第二部分是拿出来j只🐏直接一口气运过去，再加上额外产生的人回去一趟的成本，所有这样划分的方法都尝试后还有一种情况是全程只会走一趟，即直接是cross_time[i]，取最小即可。这样一轮循环的时间复杂度为$\Theta(n)$故总的时间复杂度为$\Theta(n^2)$，在给定的范围内提交实现了ac。

## C. Ant Foraging

> 在一个大小为 m×n的矩形网格中，分散着一定数量的食物。一只蚂蚁从左上角 (1, 1) 开始旅行，向右下角 (m, n) 移动以收集食物。当到达右下角后，蚂蚁必须返回到起点来收集更多食物。在外出旅程中，蚂蚁只能向右或向下移动，而在返回旅程中，它只能向左或向上移动。
>
> 每个单元格都包含一定数量的食物，但起点 (1, 1) 和目的地 (m, n) 没有食物。目标是找到两条路径（外出和返回），使收集的食物总量最大化。重要的是，每个单元格（除起点和终点）只能被访问一次。这意味着在外出旅程中收集的食物不能在返回旅程中再次收集。

### 问题分析

一去一回实际上可以看成两次去（回来的路倒着走就行），其中每趟都只能左或下，方便起见，对应计算机中数组的下表规则，改为选择两个从(0,0)到(m-1,n-1)的路径，使得路径上的食物总和最大

下面再来看每条路径上的特点，由于每一趟都只能左或者下，又是从(0,0)起步的，假设走了step步，到了(x,y)位置，则有

$step=x+y$，如：走了三步下下右，到了(2,1)

原本为了遍历两条路径中每个点的遍历情况，原本需要看四个坐标$(x_1,y_1)(x_2,y_2)$，在保证了$step=x+y$后，只需要用$step,x_1,x_2$这三个维度就可以遍历完所有的情况

记动态规划所用的数组为dp\[step]\[x~1~]\[x~2~]，表示该路径走到第$step$步时，第一条路线在$（x_1,step-x_1)$位置，第二条路线在$(x_2,step-x_2)$位置时的能收集到的最大食物量。

转移函数(非边界条件下)为
$$
\begin{eqnarray}
maxfood[step][x_1][x_2] =&max&(dp[step-1][x_1][x_2], dp[step-1][x_1-1][x_2], dp[step-1][x_1][x_2-1],dp[step-1][x_1-1][x_2-1])
\end{eqnarray}
$$
四个选项分别代表这一步路径1路径2都下，路径1右路径2下，路径1下路径2右，路径1路径2都右

选出这个格子最大积累食物的路径，之后再加上这两条路径上的食物，但需要避免重复收集

注意到如果两个格子被重复访问，则该格子在这两个路径中一定有$step$相同，则此时一定也有$x_1=x_2$，那么我们在遍历时只需要检查$x_1==x_2$即可，更新方式如下：
$$
\begin {equation}
dp[step][x_1][x_2] =maxfood[step][x_1][x_2]+food[x_1][y_1]+(x_1\ne x_2?)\times food[x_2][y_2]
\end {equation}
$$


开始状态为$dp[0][0][0]=0$，终结状态为$dp[m+n-2][m-1][m-1]$

遍历计算到结尾即可，最终时间和空间复杂度都为$\Theta(n^3)$



